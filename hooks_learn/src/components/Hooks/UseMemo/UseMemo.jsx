import React, { useState, useMemo } from 'react';
import styles from './UseMemo.module.scss';

const sum = n => {
    console.log('asdfsdf') // если использовать просто const result = sum(num) то мы увидим, что при нажатии на h1 по кд будет выводиться 'asdfsdf', а щначит опять выполняется функция sum, но ведь число не меняется
    return n + n;
}

export const UseMemo = () => {

    const [num, setNum] = useState(1);
    const [isGreen, setIsGreen] = useState(true);
    // const result = sum(num) // выполняется повторно при повторном рендеринге компонента. Блять, этот повторный рендеринг может быть много раз
    const result = useMemo(() => sum(num), [num]); // заебато, ноль выполнений функции sum, пока не изменится именно сам num

    return(
        <main>
            <p className={styles.info}>useMemo это перехват реакции, который позволяет вам кэшировать результат вычисления между повторными визуализациями.</p>
            <p className={styles.info}>У функциональных компонентов есть проблема - весь код в теле выполняется при каждом обновлении. Изменили состояние компонента, обновился родительский компонент или же изменился пропс - постоянно будет выполняться в весь код внутри.</p>
            <p className={styles.info}>Обычно это не проблема, потому что большинство вычислений выполняются очень быстро. Однако, если вы фильтруете или преобразуете большой массив или выполняете какие-то дорогостоящие вычисления, вы можете пропустить повторное выполнение, если данные не изменились. Если оба todos и tab совпадают с тем, что было во время последнего рендеринга, перенос вычисления в useMemo как ранее, позволяет повторно использовать visibleTodos уже выполненные ранее вычисления.</p>
            <p className={styles.info}>useMemo ожидает два аргумента: 
                                        Вычислительную функцию, не принимающую никаких аргументов и возвращающую некоторое значение.
                                        Массив зависимостей, включающий в себя все значения, находящиеся внутри компонента и использующиеся при вычислении</p>
            <p className={styles.info}>Итак, как этот хук работает в ReactJS? Давайте воспользуемся реальным примером, чтобы объяснить эту концепцию. Предположим, что ваш школьный учитель спросил вас об общем количестве учеников в вашем классе, вы сосчитали учеников и сказали ему, что их было 50. Вам не нужно будет пересчитывать снова, когда он спросит вас на следующий день. Все, что вам нужно, это дать ему тот же ответ, что и вчера, если только в ваш класс не были добавлены новые ученики; теперь вам нужно посчитать или вычислить снова. Вот как работает React memo hook.</p>
            <p className={styles.info}>В данном примере есть два состояния: num и isGreen. Проблема в том, что при изменении isGreen будет рендериться компонент, а значит снова вызвана функция sum, чего нам нужна. Но если использовать useMemo, то мы решим эту проблему</p>
            <div className={styles.memo__practice}>
                <h1 onClick={() => setIsGreen(!isGreen)}
                    style={{ color: isGreen ? "green" : "red" }}
                > Example </h1>
                <h2>
                    Sum: {result}
                </h2>
                <button onClick={() => setNum(num + 1)}>➕</button>
            </div>
        </main>
    );
};
